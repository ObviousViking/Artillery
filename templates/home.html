{% extends "base.html" %}
{% block content %}

<div class="row mb-4">
  <div class="col-12">
    <div class="card shadow-sm">
      <div class="card-body">
        <h1 class="card-title mb-3">Welcome to Artillery</h1>
        <p class="mb-3">
          Artillery is your lightweight web front-end for
          <code>gallery-dl</code>. Create repeatable download tasks, schedule
          them with cron, and keep everything isolated per task folder.
        </p>

        <ul class="mb-3">
          <li>Each task has its own folder under <code>/tasks/&lt;task-name&gt;</code>.</li>
          <li>Downloads go to <code>/downloads</code> using your global <code>gallery-dl.conf</code>.</li>
          <li>Tasks can be run manually, paused, or scheduled via cron.</li>
          <li>All output is logged to each taskâ€™s <code>logs.txt</code> for troubleshooting.</li>
        </ul>

        <div class="d-flex flex-wrap gap-2">
          <a href="{{ url_for('tasks') }}" class="btn btn-danger">View tasks</a>
          <a href="{{ url_for('config_page') }}" class="btn btn-outline-light">Edit config</a>
        </div>
      </div>
    </div>
  </div>
</div>

{% if media_wall_enabled %}
<!-- Media wall -->
<div class="row">
  <div class="col-12">
    <div class="card shadow-sm">
      <div class="card-body">
        <h5 class="card-title mb-3">Media wall</h5>

        <div id="media-wall-container"
             data-rows="3"
             data-limit="150"
             data-poll-ms="15000"
             data-server-has-media="{{ '1' if has_media else '0' }}">

          <p id="media-wall-loader" class="text-muted small mb-2">
            Loading media wall...
          </p>

          <p id="media-wall-empty" class="text-muted mb-0" {% if has_media %}style="display:none"{% endif %}>
            No media cached yet. Run a task, then refresh the media wall.
          </p>

          <!-- initial server-render (fast first paint) -->
          <div class="media-wall {% if has_media %}media-wall-ready{% endif %}" id="media-wall">
            {% if has_media %}
              {% for row in recent_rows %}
                {% if row %}
                <div class="media-wall-row">
                  <div class="media-strip
                    {% if loop.index0 == 1 %}
                      media-strip-right
                    {% else %}
                      media-strip-left
                    {% endif %}">
                    {# duplicate items to allow continuous scroll #}
                    {% for _ in range(2) %}
                      {% for item in row %}
                        <div class="media-item">
                          <a href="{{ item }}" target="_blank" class="d-block">
                            <img src="{{ item }}" alt="media" class="media-img" loading="lazy" />
                          </a>
                        </div>
                      {% endfor %}
                    {% endfor %}
                  </div>
                </div>
                {% endif %}
              {% endfor %}
            {% endif %}
          </div>
        </div>

        <script>
        (function () {
          const container = document.getElementById("media-wall-container");
          if (!container) return;

          const rows = parseInt(container.dataset.rows || "3", 10);
          const limit = parseInt(container.dataset.limit || "150", 10);
          const pollMs = parseInt(container.dataset.pollMs || "15000", 10);
          const serverHasMedia = container.dataset.serverHasMedia === "1";

          const loader = document.getElementById("media-wall-loader");
          const emptyMsg = document.getElementById("media-wall-empty");
          const wall = document.getElementById("media-wall");

          let lastSig = "";

          function hideLoader() { if (loader) loader.style.display = "none"; }
          function setEmpty(isEmpty) { if (emptyMsg) emptyMsg.style.display = isEmpty ? "" : "none"; }
          function setReady(el = wall) { if (el) el.classList.add("media-wall-ready"); }
          function buildUrl(baseUrl, v) { return baseUrl + (baseUrl.includes("?") ? "&" : "?") + "v=" + encodeURIComponent(v); }

          // marquee helpers (unchanged)
          let _marqueeTimer = null;
          function scheduleInitMarquees() {
            clearTimeout(_marqueeTimer);
            _marqueeTimer = setTimeout(initMarquees, 50);
          }
          function initMarquees() {
            const strips = document.querySelectorAll(".media-strip");
            strips.forEach(strip => {
              const kids = strip.children;
              if (!kids || kids.length < 2) return;
              const half = Math.floor(kids.length / 2);
              if (!kids[half]) return;
              const stripRect = strip.getBoundingClientRect();
              const kidRect = kids[half].getBoundingClientRect();
              const distance = kidRect.left - stripRect.left;
              if (!(distance > 0)) return;
              const speed = 16; // px/sec
              const duration = Math.max(25, distance / speed);
              const prev = strip.__loopDistance || 0;
              const prevDur = strip.__loopDuration || 0;
              if (Math.abs(prev - distance) < 0.1 && Math.abs(prevDur - duration) < 0.05) return;
              strip.__loopDistance = distance;
              strip.__loopDuration = duration;
              strip.style.setProperty("--loop-distance", distance.toFixed(2) + "px");
              strip.style.setProperty("--duration", duration.toFixed(2) + "s");
            });
          }

          // build playlist logic (unchanged algorithm)
          function buildRows(items) {
            const perRow = Math.min(80, Math.max(30, items.length));
            let pool = items.slice();
            for (let i = pool.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [pool[i], pool[j]] = [pool[j], pool[i]];
            }
            let poolIdx = 0;
            const usedGlobal = new Set();
            function reshufflePool() {
              for (let i = pool.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [pool[i], pool[j]] = [pool[j], pool[i]];
              }
            }
            function nextFromPool() {
              if (!pool.length) return null;
              const it = pool[poolIdx++];
              if (poolIdx >= pool.length) {
                poolIdx = 0;
                reshufflePool();
              }
              return it;
            }
            function buildPlaylist(count) {
              const out = [];
              let guard = 0;
              while (out.length < count && guard < count * 10) {
                guard++;
                const it = nextFromPool();
                if (!it) break;
                const key = (it && (it.name || it.url)) || it;
                if (usedGlobal.has(key)) continue;
                usedGlobal.add(key);
                out.push(it);
              }
              while (out.length < count) {
                const it = nextFromPool();
                if (!it) break;
                out.push(it);
              }
              return out;
            }

            const rowsOut = [];
            for (let rowIdx = 0; rowIdx < rows; rowIdx++) {
              const rowItems = buildPlaylist(perRow);
              if (!rowItems.length) continue;
              rowsOut.push(rowItems);
            }
            return rowsOut;
          }

          // wait for at least minLoaded images to succeed or timeout
          function waitForSome(promises, minLoaded, timeoutMs) {
            return new Promise(resolve => {
              let loaded = 0;
              let done = false;
              const timers = [];
              promises.forEach(p => {
                p.then(ok => {
                  loaded += 1;
                  if (!done && loaded >= minLoaded) {
                    done = true;
                    timers.forEach(t => clearTimeout(t));
                    resolve(true);
                  }
                }).catch(() => {
                  // ignore individual failures
                });
              });
              timers.push(setTimeout(() => {
                if (!done) {
                  done = true;
                  resolve(false);
                }
              }, timeoutMs));
            });
          }

          // progressive render: build off-DOM, preload a small set, then cross-fade swap
          function render(items) {
            if (!container) return;
            if (!items || !items.length) {
              setEmpty(true);
              hideLoader();
              setReady();
              return;
            }
            setEmpty(false);

            const rowsData = buildRows(items);

            // build new wall DOM
            const newWall = document.createElement("div");
            newWall.className = "media-wall";
            newWall.style.opacity = "0";
            newWall.style.transition = "opacity 350ms ease";

            const preloadImgs = [];
            const preloadLimit = Math.min(12, Math.max(6, Math.floor(items.length * 0.1))); // preload a small sample
            let preloadCount = 0;

            rowsData.forEach((rowItems, rowIdx) => {
              const rowDiv = document.createElement("div");
              rowDiv.className = "media-wall-row";
              const strip = document.createElement("div");
              strip.className = "media-strip " + (rowIdx === 1 ? "media-strip-right" : "media-strip-left");

              for (let r = 0; r < 2; r++) {
                rowItems.forEach(it => {
                  const itemDiv = document.createElement("div");
                  itemDiv.className = "media-item";

                  const a = document.createElement("a");
                  a.className = "d-block";
                  a.target = "_blank";
                  const url = (typeof it === "string") ? it : (it.url || it);
                  const mtime = (it && (it.mtime || it.mtime === 0)) ? (it.mtime) : Date.now();
                  a.href = buildUrl(url, mtime);

                  const img = document.createElement("img");
                  img.className = "media-img";
                  img.loading = "lazy";
                  img.alt = "media";
                  img.style.opacity = "0";
                  img.style.transition = "opacity 300ms ease";
                  // don't set src immediately if we plan to preload; set data-src for fallback
                  const src = buildUrl(url, mtime);
                  img.dataset.src = src;

                  // attach onload to fade in when image is set
                  img.addEventListener("load", () => {
                    img.style.opacity = "1";
                    scheduleInitMarquees();
                  }, { once: true });

                  a.appendChild(img);
                  itemDiv.appendChild(a);
                  strip.appendChild(itemDiv);

                  // collect preload promises for a small sample
                  if (preloadCount < preloadLimit) {
                    preloadCount++;
                    preloadImgs.push(new Promise((resolve, reject) => {
                      const p = new Image();
                      p.onload = () => resolve(true);
                      p.onerror = () => resolve(false); // resolve on error to avoid blocking
                      p.src = src;
                    }));
                  }
                });
              }

              rowDiv.appendChild(strip);
              newWall.appendChild(rowDiv);
            });

            // once minLoaded or timeout, attach newWall and then set src for all imgs to start actual loading
            const minNeeded = Math.max(1, Math.floor(preloadImgs.length * 0.4)); // require 40% of sample to be ready
            waitForSome(preloadImgs, minNeeded, 1200).then(() => {
              // insert new wall next to old wall
              if (wall && wall.parentNode) {
                wall.parentNode.insertBefore(newWall, wall.nextSibling);
              } else {
                container.appendChild(newWall);
              }

              // trigger actual image loads for all imgs in newWall
              newWall.querySelectorAll("img.media-img").forEach(imgEl => {
                if (!imgEl.src) {
                  imgEl.src = imgEl.dataset.src || "";
                }
              });

              // cross-fade
              requestAnimationFrame(() => {
                newWall.style.opacity = "1";
                if (wall) wall.style.transition = "opacity 300ms ease", wall.style.opacity = "0";
              });

              // after transition remove old wall and update reference
              setTimeout(() => {
                if (wall && wall.parentNode) wall.parentNode.removeChild(wall);
                // set new wall as the live wall variable for future swaps
                // mutate the DOM reference used elsewhere
                // NOTE: we rely on the original id only for initial render; update id for future queries
                newWall.id = "media-wall";
                // update our local wall reference
                // eslint-disable-next-line no-unused-vars
                window.__ARTILLERY_MEDIA_WALL = newWall;
                setReady(newWall);
                hideLoader();
                scheduleInitMarquees();
              }, 450);
            }).catch(() => {
              // fallback: immediate replacement if something goes wrong
              wall.innerHTML = newWall.innerHTML;
              newWall.querySelectorAll("img.media-img").forEach(imgEl => {
                if (!imgEl.src) imgEl.src = imgEl.dataset.src || "";
              });
              hideLoader();
              setReady();
              scheduleInitMarquees();
            });
          }

          async function refresh() {
            try {
              const res = await fetch("/mediawall/api/cache_index", { cache: "no-store" });
              if (!res.ok) return;
              const data = await res.json();
              const items = (data.items || []).slice(0, limit);
              const sig = items.map(i => (typeof i === "string" ? i : (i.name || i.url)) + ":" + (i.mtime || "")).join("|");
              if (sig && sig === lastSig) {
                hideLoader();
                setReady();
                return;
              }
              lastSig = sig;
              render(items);
            } catch (e) {
              // silent fail
            }
          }

          document.addEventListener("DOMContentLoaded", () => {
            scheduleInitMarquees();
            setTimeout(scheduleInitMarquees, 250);
            setTimeout(scheduleInitMarquees, 1000);
            window.addEventListener("resize", () => setTimeout(scheduleInitMarquees, 150));

            if (serverHasMedia) {
              setTimeout(() => refresh(), Math.max(2000, pollMs));
            } else {
              setTimeout(() => refresh(), 2000);
            }

            setInterval(refresh, pollMs);
          });
        })();
        </script>

      </div>
    </div>
  </div>
</div>
{% endif %}

{% endblock %}
